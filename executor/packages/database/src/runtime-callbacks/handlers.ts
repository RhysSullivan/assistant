import type { ActionCtx, MutationCtx, QueryCtx } from "../../convex/_generated/server";
import type { Id } from "../../convex/_generated/dataModel.d.ts";
import type { PendingApprovalRecord } from "../../../core/src/types";

type InternalApi = typeof import("../../convex/_generated/api").internal;

function timingSafeEqual(a: string, b: string): boolean {
  const encoder = new TextEncoder();
  const left = encoder.encode(a);
  const right = encoder.encode(b);

  const maxLength = Math.max(left.length, right.length);
  let mismatch = left.length ^ right.length;
  for (let i = 0; i < maxLength; i += 1) {
    mismatch |= (left[i] ?? 0) ^ (right[i] ?? 0);
  }

  return mismatch === 0;
}

function requireInternalSecret(secret: string): void {
  const expected = process.env.EXECUTOR_INTERNAL_TOKEN;
  if (!expected) {
    throw new Error("EXECUTOR_INTERNAL_TOKEN is not configured");
  }
  if (!timingSafeEqual(secret, expected)) {
    throw new Error("Unauthorized: invalid internal secret");
  }
}

export async function handleToolCallHandler(
  ctx: Pick<ActionCtx, "runAction">,
  internalApi: InternalApi,
  args: {
    internalSecret: string;
    runId: string;
    callId: string;
    toolPath: string;
    input?: Record<string, unknown>;
  },
): Promise<string> {
  requireInternalSecret(args.internalSecret);
  return await ctx.runAction(internalApi.executorNode.handleExternalToolCall, {
    runId: args.runId,
    callId: args.callId,
    toolPath: args.toolPath,
    input: args.input as Record<string, any> | undefined,
  });
}

export async function completeRunHandler(
  ctx: Pick<MutationCtx, "runMutation">,
  internalApi: InternalApi,
  args: {
    internalSecret: string;
    runId: string;
    status: "completed" | "failed" | "timed_out" | "denied";
    exitCode?: number;
    error?: string;
    durationMs?: number;
  },
) {
  requireInternalSecret(args.internalSecret);

  return await ctx.runMutation(internalApi.executor.completeRuntimeRun, {
    runId: args.runId,
    status: args.status,
    exitCode: args.exitCode,
    error: args.error,
    durationMs: args.durationMs,
  });
}

export async function getApprovalStatusHandler(
  ctx: Pick<QueryCtx, "runQuery">,
  internalApi: InternalApi,
  args: {
    internalSecret: string;
    runId: string;
    approvalId: string;
  },
) {
  requireInternalSecret(args.internalSecret);

  const approval = await ctx.runQuery(internalApi.database.getApproval, {
    approvalId: args.approvalId,
  });

  if (!approval || approval.taskId !== args.runId) {
    return { status: "missing" as const };
  }

  return { status: approval.status };
}

export async function getTaskWatchStatusHandler(
  ctx: Pick<QueryCtx, "runQuery">,
  internalApi: InternalApi,
  args: {
    internalSecret: string;
    runId: string;
    workspaceId: Id<"workspaces">;
  },
) {
  requireInternalSecret(args.internalSecret);

  const task = await ctx.runQuery(internalApi.database.getTaskInWorkspace, {
    taskId: args.runId,
    workspaceId: args.workspaceId,
  });

  if (!task) {
    return {
      pendingApprovalCount: 0,
    };
  }

  const pendingApprovals = await ctx.runQuery(internalApi.database.listPendingApprovals, {
    workspaceId: args.workspaceId,
  });

  const pendingApprovalCount = pendingApprovals.filter((approval: PendingApprovalRecord) => approval.taskId === args.runId).length;

  return {
    status: task.status,
    pendingApprovalCount,
  };
}
